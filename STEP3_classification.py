# -*- coding: utf-8 -*-
"""Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SyOnt6Gi4ynpSXcw3_wTPI2H0DvK2FC-
"""

# Ensure you run the following installations separately, outside of the script
# pip install pandas nltk textblob afinn

# Import necessary libraries
import pandas as pd
import nltk
from textblob import TextBlob
from afinn import Afinn
from nltk.corpus import wordnet
from nltk.tokenize import word_tokenize
from nltk.corpus import sentiwordnet as swn

# Download necessary resources (run this only once)
nltk.download('opinion_lexicon')
nltk.download('wordnet')
nltk.download('sentiwordnet')
nltk.download('punkt')

# Load the dataset
df = pd.read_csv('preprocessed.csv')

# Preprocess text
def preprocess_text(text):
    tokens = word_tokenize(text.lower())
    return [word for word in tokens if word.isalnum()]

# NLTK Opinion Lexicon
with open('positive.txt', 'r') as file:
    positive_words = set(file.read().splitlines())

with open('negative.txt', 'r') as file:
    negative_words = set(file.read().splitlines())

def classify_opinion_lexicon(tokens):
    pos_count = sum(1 for word in tokens if word in positive_words)
    neg_count = sum(1 for word in tokens if word in negative_words)
    return pos_count - neg_count

# TextBlob Sentiment Polarity
def classify_textblob(comment):
    return TextBlob(comment).sentiment.polarity

# SentiWordNet Sentiment Scores
def classify_sentiwordnet(tokens):
    pos_score, neg_score = 0, 0
    for token in tokens:
        synsets = wordnet.synsets(token)
        if synsets:
            senti_synset = swn.senti_synset(synsets[0].name())
            pos_score += senti_synset.pos_score()
            neg_score += senti_synset.neg_score()
    return pos_score - neg_score

# AFINN Sentiment Scoring
afinn = Afinn()

# Custom Negative Word List
custom_neg_words = {
    "abysmal", "adverse", "alarming", "angry", "annoyed", "anxious",
    "appalling", "arrogant", "awful", "bad", "bitter", "boring", "broken",
    "chaotic", "clueless", "complain", "complicated", "confused", "corrupt",
    "creepy", "cruel", "crummy", "dangerous", "deceptive", "defective",
    "depressed", "depressing", "desperate", "detrimental", "dirty", "disappoint",
    "disastrous", "discontent", "discouraged", "disgust", "dishonest",
    "disorganized", "dissatisfied", "distasteful", "dreadful", "embarrassed",
    "embarrassing", "error", "evil", "fail", "faulty", "fear", "filthy",
    "frustrated", "frustrating", "greedy", "grim", "guilty", "haggard",
    "hateful", "heartbreaking", "hell", "horrible", "hostile", "hurt",
    "hysterical", "ignorant", "immoral", "impatient", "impossible",
    "incompetent", "inconsiderate", "ineffective", "inefficient", "inferior",
    "insecure", "insensitive", "insulting", "intolerant", "irate", "irresponsible",
    "jealous", "lousy", "malicious", "mediocre", "messy", "miserable", "misleading",
    "mistake", "negligent", "nervous", "nightmare", "noisy", "nonsense",
    "offensive", "outrageous", "painful", "pathetic", "perplexing",
    "pessimistic", "pitiful", "poor", "problematic", "reckless", "regret",
    "reject", "ridiculous", "rude", "sad", "scared", "selfish", "shameful",
    "shocking", "sick", "sloppy", "slow", "smelly", "stressful", "stupid",
    "subpar", "terrible", "threatening", "tired", "tragic", "ugly", "unacceptable",
    "unbearable", "uncaring", "uncomfortable", "unfair", "unhappy", "unhelpful",
    "unimpressive", "unpleasant", "unsatisfactory", "unscrupulous",
    "unstable", "upset", "useless", "vague", "vengeful", "vindictive",
    "violent", "vulgar", "waste", "weak", "weird", "wicked", "worn-out",
    "worried", "worse", "worst", "worthless", "wrong"
}

def classify_afinn(comment):
    return afinn.score(comment)

def classify_custom_neg_list(tokens):
    return any(word in custom_neg_words for word in tokens)

# Aggregate Results
def aggregate_results(opinion_score, textblob_score, sentiwordnet_score, afinn_score, custom_check):
    scores = [opinion_score, textblob_score, sentiwordnet_score, afinn_score]
    avg_score = sum(scores) / len(scores)
    if custom_check:
        avg_score -= 0.5  # Apply a negative bias if a custom word matches
    return 1 if avg_score > 0 else 0

# Process Comments
def process_comments(df):
    results = []
    for comment in df['new_comments']:
        tokens = preprocess_text(comment)
        opinion_score = classify_opinion_lexicon(tokens)
        textblob_score = classify_textblob(comment)
        sentiwordnet_score = classify_sentiwordnet(tokens)
        afinn_score = classify_afinn(comment)
        custom_check = classify_custom_neg_list(tokens)
        final_classification = aggregate_results(opinion_score, textblob_score, sentiwordnet_score, afinn_score, custom_check)
        results.append(final_classification)
    df['sentiment'] = results
    return df

# Main Execution
if __name__ == "__main__":
    # Load dataset
    df = pd.read_csv('preprocessed.csv')  # Replace with your dataset file
    df['new_comments'] = df['new_comments'].fillna('')
    df = process_comments(df)
    # Save results
    df.to_csv('classified_comments.csv', index=False)
    print("Sentiment analysis completed. Results saved to 'classified_comments.csv'.")
